{"ast":null,"code":"// External libraries are lazy-loaded only if these file types exist.\nvar Yaml = null,\n    VisionmediaYaml = null,\n    Coffee = null,\n    Iced = null,\n    CSON = null,\n    PPARSER = null,\n    JSON5 = null,\n    TOML = null,\n    HJSON = null,\n    XML = null; // Define soft dependencies so transpilers don't include everything\n\nvar COFFEE_2_DEP = 'coffeescript',\n    COFFEE_DEP = 'coffee-script',\n    ICED_DEP = 'iced-coffee-script',\n    JS_YAML_DEP = 'js-yaml',\n    YAML_DEP = 'yaml',\n    JSON5_DEP = 'json5',\n    HJSON_DEP = 'hjson',\n    TOML_DEP = 'toml',\n    CSON_DEP = 'cson',\n    PPARSER_DEP = 'properties',\n    XML_DEP = 'x2js',\n    TS_DEP = 'ts-node';\nvar Parser = module.exports;\n\nParser.parse = function (filename, content) {\n  var parserName = filename.substr(filename.lastIndexOf('.') + 1); // file extension\n\n  if (typeof definitions[parserName] === 'function') {\n    return definitions[parserName](filename, content);\n  } // TODO: decide what to do in case of a missing parser\n\n};\n\nParser.xmlParser = function (filename, content) {\n  if (!XML) {\n    XML = require(XML_DEP);\n  }\n\n  var x2js = new XML();\n  var configObject = x2js.xml2js(content);\n  var rootKeys = Object.keys(configObject);\n\n  if (rootKeys.length === 1) {\n    return configObject[rootKeys[0]];\n  }\n\n  return configObject;\n};\n\nParser.jsParser = function (filename, content) {\n  return require(filename);\n};\n\nParser.tsParser = function (filename, content) {\n  if (!require.extensions['.ts']) {\n    require(TS_DEP).register({\n      lazy: true,\n      compilerOptions: {\n        allowJs: true\n      }\n    });\n  } // Imports config if it is exported via module.exports = ...\n  // See https://github.com/lorenwest/node-config/issues/524\n\n\n  var configObject = require(filename); // Because of ES6 modules usage, `default` is treated as named export (like any other)\n  // Therefore config is a value of `default` key.\n\n\n  if (configObject.default) {\n    return configObject.default;\n  }\n\n  return configObject;\n};\n\nParser.coffeeParser = function (filename, content) {\n  // .coffee files can be loaded with either coffee-script or iced-coffee-script.\n  // Prefer iced-coffee-script, if it exists.\n  // Lazy load the appropriate extension\n  if (!Coffee) {\n    Coffee = {}; // The following enables iced-coffee-script on .coffee files, if iced-coffee-script is available.\n    // This is commented as per a decision on a pull request.\n    //try {\n    //  Coffee = require('iced-coffee-script');\n    //}\n    //catch (e) {\n    //  Coffee = require('coffee-script');\n    //}\n\n    try {\n      // Try to load coffeescript\n      Coffee = require(COFFEE_2_DEP);\n    } catch (e) {\n      // If it doesn't exist, try to load it using the deprecated module name\n      Coffee = require(COFFEE_DEP);\n    } // coffee-script >= 1.7.0 requires explicit registration for require() to work\n\n\n    if (Coffee.register) {\n      Coffee.register();\n    }\n  } // Use the built-in parser for .coffee files with coffee-script\n\n\n  return require(filename);\n};\n\nParser.icedParser = function (filename, content) {\n  Iced = require(ICED_DEP); // coffee-script >= 1.7.0 requires explicit registration for require() to work\n\n  if (Iced.register) {\n    Iced.register();\n  }\n};\n\nParser.yamlParser = function (filename, content) {\n  if (!Yaml && !VisionmediaYaml) {\n    // Lazy loading\n    try {\n      // Try to load the better js-yaml module\n      Yaml = require(JS_YAML_DEP);\n    } catch (e) {\n      try {\n        // If it doesn't exist, load the fallback visionmedia yaml module.\n        VisionmediaYaml = require(YAML_DEP);\n      } catch (e) {}\n    }\n  }\n\n  if (Yaml) {\n    return Yaml.load(content);\n  } else if (VisionmediaYaml) {\n    // The yaml library doesn't like strings that have newlines but don't\n    // end in a newline: https://github.com/visionmedia/js-yaml/issues/issue/13\n    content += '\\n';\n    return VisionmediaYaml.eval(Parser.stripYamlComments(content));\n  } else {\n    console.error('No YAML parser loaded.  Suggest adding js-yaml dependency to your package.json file.');\n  }\n};\n\nParser.jsonParser = function (filename, content) {\n  try {\n    return JSON.parse(content);\n  } catch (e) {\n    // All JS Style comments will begin with /, so all JSON parse errors that\n    // encountered a syntax error will complain about this character.\n    if (e.name !== 'SyntaxError' || e.message.indexOf('Unexpected token /') !== 0) {\n      throw e;\n    }\n\n    if (!JSON5) {\n      JSON5 = require(JSON5_DEP);\n    }\n\n    return JSON5.parse(content);\n  }\n};\n\nParser.json5Parser = function (filename, content) {\n  if (!JSON5) {\n    JSON5 = require(JSON5_DEP);\n  }\n\n  return JSON5.parse(content);\n};\n\nParser.hjsonParser = function (filename, content) {\n  if (!HJSON) {\n    HJSON = require(HJSON_DEP);\n  }\n\n  return HJSON.parse(content);\n};\n\nParser.tomlParser = function (filename, content) {\n  if (!TOML) {\n    TOML = require(TOML_DEP);\n  }\n\n  return TOML.parse(content);\n};\n\nParser.csonParser = function (filename, content) {\n  if (!CSON) {\n    CSON = require(CSON_DEP);\n  } // Allow comments in CSON files\n\n\n  if (typeof CSON.parseSync === 'function') {\n    return CSON.parseSync(Parser.stripComments(content));\n  }\n\n  return CSON.parse(Parser.stripComments(content));\n};\n\nParser.propertiesParser = function (filename, content) {\n  if (!PPARSER) {\n    PPARSER = require(PPARSER_DEP);\n  }\n\n  return PPARSER.parse(content, {\n    namespaces: true,\n    variables: true,\n    sections: true\n  });\n};\n/**\n * Strip all Javascript type comments from the string.\n *\n * The string is usually a file loaded from the O/S, containing\n * newlines and javascript type comments.\n *\n * Thanks to James Padolsey, and all who contributed to this implementation.\n * http://james.padolsey.com/javascript/javascript-comment-removal-revisted/\n *\n * @protected\n * @method stripComments\n * @param fileStr {string} The string to strip comments from\n * @param stringRegex {RegExp} Optional regular expression to match strings that\n *   make up the config file\n * @return {string} The string with comments stripped.\n */\n\n\nParser.stripComments = function (fileStr, stringRegex) {\n  stringRegex = stringRegex || /(['\"])(\\\\\\1|.)+?\\1/g;\n  var uid = '_' + +new Date(),\n      primitives = [],\n      primIndex = 0;\n  return fileStr\n  /* Remove strings */\n  .replace(stringRegex, function (match) {\n    primitives[primIndex] = match;\n    return uid + '' + primIndex++;\n  })\n  /* Remove Regexes */\n  .replace(/([^\\/])(\\/(?!\\*|\\/)(\\\\\\/|.)+?\\/[gim]{0,3})/g, function (match, $1, $2) {\n    primitives[primIndex] = $2;\n    return $1 + (uid + '') + primIndex++;\n  })\n  /*\n  - Remove single-line comments that contain would-be multi-line delimiters\n      E.g. // Comment /* <--\n  - Remove multi-line comments that contain would be single-line delimiters\n      E.g. /* // <--\n  */\n  .replace(/\\/\\/.*?\\/?\\*.+?(?=\\n|\\r|$)|\\/\\*[\\s\\S]*?\\/\\/[\\s\\S]*?\\*\\//g, '')\n  /*\n  Remove single and multi-line comments,\n  no consideration of inner-contents\n  */\n  .replace(/\\/\\/.+?(?=\\n|\\r|$)|\\/\\*[\\s\\S]+?\\*\\//g, '')\n  /*\n  Remove multi-line comments that have a replaced ending (string/regex)\n  Greedy, so no inner strings/regexes will stop it.\n  */\n  .replace(RegExp('\\\\/\\\\*[\\\\s\\\\S]+' + uid + '\\\\d+', 'g'), '')\n  /* Bring back strings & regexes */\n  .replace(RegExp(uid + '(\\\\d+)', 'g'), function (match, n) {\n    return primitives[n];\n  });\n};\n/**\n * Strip YAML comments from the string\n *\n * The 2.0 yaml parser doesn't allow comment-only or blank lines.  Strip them.\n *\n * @protected\n * @method stripYamlComments\n * @param fileStr {string} The string to strip comments from\n * @return {string} The string with comments stripped.\n */\n\n\nParser.stripYamlComments = function (fileStr) {\n  // First replace removes comment-only lines\n  // Second replace removes blank lines\n  return fileStr.replace(/^\\s*#.*/mg, '').replace(/^\\s*[\\n|\\r]+/mg, '');\n};\n\nvar order = ['js', 'ts', 'json', 'json5', 'hjson', 'toml', 'coffee', 'iced', 'yaml', 'yml', 'cson', 'properties', 'xml'];\nvar definitions = {\n  coffee: Parser.coffeeParser,\n  cson: Parser.csonParser,\n  hjson: Parser.hjsonParser,\n  iced: Parser.icedParser,\n  js: Parser.jsParser,\n  json: Parser.jsonParser,\n  json5: Parser.json5Parser,\n  properties: Parser.propertiesParser,\n  toml: Parser.tomlParser,\n  ts: Parser.tsParser,\n  xml: Parser.xmlParser,\n  yaml: Parser.yamlParser,\n  yml: Parser.yamlParser\n};\n\nParser.getParser = function (name) {\n  return definitions[name];\n};\n\nParser.setParser = function (name, parser) {\n  definitions[name] = parser;\n\n  if (order.indexOf(name) === -1) {\n    order.push(name);\n  }\n};\n\nParser.getFilesOrder = function (name) {\n  if (name) {\n    return order.indexOf(name);\n  }\n\n  return order;\n};\n\nParser.setFilesOrder = function (name, newIndex) {\n  if (Array.isArray(name)) {\n    return order = name;\n  }\n\n  if (typeof newIndex === 'number') {\n    var index = order.indexOf(name);\n    order.splice(newIndex, 0, name);\n\n    if (index > -1) {\n      order.splice(index >= newIndex ? index + 1 : index, 1);\n    }\n  }\n\n  return order;\n};","map":null,"metadata":{},"sourceType":"script"}