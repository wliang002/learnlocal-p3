{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n\nconst base_1 = require(\"../base\");\n\nconst context_builder_1 = require(\"../context-builder\");\n\nfunction oneOf(chains, message) {\n  return (req, _res, next) => __awaiter(this, void 0, void 0, function* () {\n    const surrogateContext = new context_builder_1.ContextBuilder().build(); // Run each group of chains in parallel, and within each group, run each chain in parallel too.\n\n    const promises = chains.map(chain => __awaiter(this, void 0, void 0, function* () {\n      const group = Array.isArray(chain) ? chain : [chain];\n      const contexts = yield Promise.all(group.map(chain => chain.run(req, {\n        saveContext: false\n      })));\n\n      const groupErrors = _.flatMap(contexts, 'errors'); // #536: The data from a chain within oneOf() can only be made available to e.g. matchedData()\n      // if its entire group is valid.\n\n\n      if (!groupErrors.length) {\n        contexts.forEach(context => {\n          surrogateContext.addFieldInstances(context.getData());\n        });\n      }\n\n      return groupErrors;\n    }));\n    req[base_1.contextsSymbol] = (req[base_1.contextsSymbol] || []).concat(surrogateContext);\n\n    try {\n      const allErrors = yield Promise.all(promises);\n      const success = allErrors.some(groupErrors => groupErrors.length === 0);\n\n      if (!success) {\n        // Only add an error to the context if no group of chains had success.\n        surrogateContext.addError(typeof message === 'function' ? message({\n          req\n        }) : message || 'Invalid value(s)', _.flatMap(allErrors));\n      }\n\n      next();\n    } catch (e) {\n      next(e);\n    }\n  });\n}\n\nexports.oneOf = oneOf;","map":null,"metadata":{},"sourceType":"script"}