{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chain_1 = require(\"../chain\");\n\nconst check_1 = require(\"./check\");\n\nconst validLocations = ['body', 'cookies', 'headers', 'params', 'query'];\nconst protectedNames = ['errorMessage', 'in'];\n\nfunction checkSchema(schema, defaultLocations = validLocations) {\n  return Object.keys(schema).map(field => {\n    const config = schema[field];\n    const chain = check_1.check(field, ensureLocations(config, defaultLocations), config.errorMessage);\n    Object.keys(config).filter(method => {\n      return config[method] && !protectedNames.includes(method);\n    }).forEach(method => {\n      if (typeof chain[method] !== 'function') {\n        console.warn(\"express-validator: a validator/sanitizer with name \".concat(method, \" does not exist\"));\n        return;\n      } // Using \"!\" because typescript doesn't know it isn't undefined.\n\n\n      const methodCfg = config[method];\n      let options = methodCfg === true ? [] : methodCfg.options || [];\n\n      if (options != null && !Array.isArray(options)) {\n        options = [options];\n      }\n\n      if (isValidatorOptions(method, methodCfg) && methodCfg.negated) {\n        chain.not();\n      }\n\n      chain[method](...options);\n\n      if (isValidatorOptions(method, methodCfg) && methodCfg.errorMessage) {\n        chain.withMessage(methodCfg.errorMessage);\n      }\n    });\n    return chain;\n  });\n}\n\nexports.checkSchema = checkSchema;\n\nfunction isValidatorOptions(method, methodCfg) {\n  return methodCfg !== true && method in chain_1.ValidatorsImpl.prototype;\n}\n\nfunction ensureLocations(config, defaults) {\n  // .filter(Boolean) is done because in can be undefined -- which is not going away from the type\n  // See https://github.com/Microsoft/TypeScript/pull/29955 for details\n  const locations = Array.isArray(config.in) ? config.in : [config.in].filter(Boolean);\n  const actualLocations = locations.length ? locations : defaults;\n  return actualLocations.filter(location => validLocations.includes(location));\n}","map":null,"metadata":{},"sourceType":"script"}